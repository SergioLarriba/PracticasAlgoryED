<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>p109 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>p109</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from typing import List, Callable

def matrix_multiplication (m_1: np.ndarray, m_2: np.ndarray)-&gt; np.ndarray: 
    &#34;&#34;&#34;Multiplica 2 matrices.
    
    Devuelve la matriz multiplicada.
    
    Args: 

        m_1 (np.ndarray): una matriz para multiplicar.
        
        m_2 (np.ndarray): una matriz para multiplicar. 
    
    Returns: 
    
        m_3 (np.ndarray): la matriz resultado de la multiplicacion de m_1 * m_2
        
    &#34;&#34;&#34; 
    return np.multiply(m_1, m_2)

def rec_bb(t: list, f: int, l: int, key: int)-&gt; int:  
    &#34;&#34;&#34;Busca un elemento en un array ordenado.
    
    Divide el array por la mitad, comprueba si el elemento que ocupa la posicion en la mitad es mayor o menor que el elemento que queremos insertar, 
    y dependiendo de lo que sea, volvemos a dividir y ejecutar el mismo proceso con la mitad superior o inferior de la tabla.
    
    Args: 

        t (list): la lista en la que queremos buscar el elemento.
        
        f (int): el indice del primer elemento de la tabla. 
        
        l (int): el indice del ultimo elemento de la tabla. 
        
        key (int): el elemento que queremos buscar
    
    Returns: 

        p (int): la posicion del elemento que queremos buscar
        
    &#34;&#34;&#34; 
    
    if f&gt;l : 
        return None
    
    mid = (f+l) // 2
    
    if key==t[mid] : 
        return mid
    elif key&lt;t[mid] : 
        return rec_bb (t, f, mid-1, key)
    else : 
        return rec_bb (t, mid+1, l, key)

def bb(t: list, f: int, l: int, key: int)-&gt; int:
    &#34;&#34;&#34;Busca un elemento en un array ordenado.
    
    Divide el array por la mitad, comprueba si el elemento que ocupa la posicion en la mitad es mayor o menor que el elemento que queremos insertar, 
    y dependiendo de lo que sea, volvemos a dividir y ejecutar el mismo proceso con la mitad superior o inferior de la tabla.
    
    Args: 

        t (list): la lista en la que queremos buscar el elemento.
        
        f (int): el indice del primer elemento de la tabla. 
        
        l (int): el indice del ultimo elemento de la tabla. 
        
        key (int): el elemento que queremos buscar
    
    Returns: 

        p (int): la posicion del elemento que queremos buscar
        
    &#34;&#34;&#34; 
    while f &lt; l:

        mid = (f + l) // 2

        if t[mid] == key:
            return mid
        elif t[mid] &lt; key:
            f = mid + 1
        else:
            l = mid - 1

def min_heapify(h: np.ndarray, i: int):
    &#34;&#34;&#34;Comprueba que los hijos son menores del padre que ocupa la posicion i.
    
    Modifica el heap de tal forma que el elemento de la posicion i, sus hijos sean menores que él.
    
    Args: 

        h (np.ndarray): un heap.
        
        i (int): la posicion del elemento el cual se quiere hacer heapify. 
        
    &#34;&#34;&#34; 
    
    while 2*i+1 &lt; len(h):
        n_i = i
        if h[int(n_i)] &gt; h[int(2*i+1)]:
            n_i = 2*i+1
        if 2*i+2 &lt; len(h) and h[int(n_i)] &gt; h[int(2*i+2)]:
            n_i = 2*i+2
        if n_i &gt; i:
            h[int(i)], h[int(n_i)] = h[int(n_i)], h[int(i)]
            i = n_i
        else:
            return

def insert_min_heap(h: np.ndarray, k: int) -&gt; np.ndarray:
    &#34;&#34;&#34;Inserta un nuevo nodo.
    
    Inserta un nuevo nodo en un min heap existente.
    
    Args: 

        h (np.ndarray): el min heap.
        
        k (int): el nuevo nodo/valor a insertar. 
    
    Returns: 

        h (np.ndarray): el min heap con el nodo insertado.
        
    &#34;&#34;&#34; 

    if h == None: 
        h == []
    
    h += [k]
    j = len(h) - 1
    
    while j&gt;=1 and h[(j-1)//2] &gt; h[j]:
        h[(j-1)//2], h[j] = h[j], h[(j-1)//2]
        j = (j-1)//2
    
    return h

def create_min_heap (h:np.ndarray): 
    &#34;&#34;&#34;Crea un min heap.
    
    Crea un min heap sobre el array que le es pasado por argumento.
    
    Args: 

        h (np.ndarray): un array de Numpy.
        
    &#34;&#34;&#34; 
    
    if (len(h)==0): 
        return
    
    i = ((len(h)-1)-1)/2
    
    while i &gt; -1: 
        min_heapify (h, i)
        i = i - 1

def pq_ini(): 
    &#34;&#34;&#34;Inicializa una cola de prioridad. 
    
    Returns: 

        pq (lista): la cola de prioridad vacia.
        
    &#34;&#34;&#34; 
    pq = []
    return pq 
  
def pq_insert (h: np.ndarray, k:int)-&gt; np.ndarray:  
    &#34;&#34;&#34;Inserta un nuevo valor en la cola de prioridad.
    
    Inserta un nuevo nodo en un min heap existente.
    
    Args: 

        h (np.ndarray): la cola de prioridad en la que hay que insertar el valor.
        
        k (int): el nuevo nodo/valor a insertar. 
    
    Returns: 

        h (np.ndarray): la lista con el nuevo nodo insertado.
        
    &#34;&#34;&#34; 
    
    if len(h)==0: 
        return None
    
    return insert_min_heap (h, k)

def pq_remove(h: np.ndarray)-&gt; tuple[int, np.ndarray]: 
    &#34;&#34;&#34;Extrae la raiz.
    
    Elimina la raiz, la reemplaza por el ultimo nodo y comprueba si sigue siendo un min heap.
    
    Args: 

        h (np.ndarray): la cola de prioridad en la que hay que extraer la raiz.
    
    Returns: 

        tuple[int, np.ndarray]: la cola de prioridad sin la raiz original y el valor extraido
        
    &#34;&#34;&#34; 
    if len(h)==0 : 
        return (h[0], h)
    
    k = h[0]
    h[0] = h[-1]
    min_heapify (h, 0)
    
    return (k, h)

def select_min_heap(h: np.ndarray, k: int)-&gt; int: 
    &#34;&#34;&#34;Retorna el valor que ocuparia la posicion k en un array ordenado.
    
    Args: 

        h (np.ndarray): el min heap.
        
        k (int): la posicion que ocuparia
    
    Returns: 

        p (int): el elemento que ocuparia la posicion k en un array ordenado
        
    &#34;&#34;&#34; 
    h_aux = []
    
    for i in range (0, k) : 
      insert_min_heap (h_aux, -h[i])

    for i in range (0, len(h)) : 
      if -h[i] &gt; h_aux[0] : 
        h_aux = pq_remove (h_aux)[1]
        h_aux = insert_min_heap(h_aux, -h[i])
    
    return -h_aux[0]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="p109.bb"><code class="name flex">
<span>def <span class="ident">bb</span></span>(<span>t: list, f: int, l: int, key: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Busca un elemento en un array ordenado.</p>
<p>Divide el array por la mitad, comprueba si el elemento que ocupa la posicion en la mitad es mayor o menor que el elemento que queremos insertar,
y dependiendo de lo que sea, volvemos a dividir y ejecutar el mismo proceso con la mitad superior o inferior de la tabla.</p>
<p>Args: </p>
<pre><code>t (list): la lista en la que queremos buscar el elemento.

f (int): el indice del primer elemento de la tabla.

l (int): el indice del ultimo elemento de la tabla.

key (int): el elemento que queremos buscar
</code></pre>
<p>Returns: </p>
<pre><code>p (int): la posicion del elemento que queremos buscar
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bb(t: list, f: int, l: int, key: int)-&gt; int:
    &#34;&#34;&#34;Busca un elemento en un array ordenado.
    
    Divide el array por la mitad, comprueba si el elemento que ocupa la posicion en la mitad es mayor o menor que el elemento que queremos insertar, 
    y dependiendo de lo que sea, volvemos a dividir y ejecutar el mismo proceso con la mitad superior o inferior de la tabla.
    
    Args: 

        t (list): la lista en la que queremos buscar el elemento.
        
        f (int): el indice del primer elemento de la tabla. 
        
        l (int): el indice del ultimo elemento de la tabla. 
        
        key (int): el elemento que queremos buscar
    
    Returns: 

        p (int): la posicion del elemento que queremos buscar
        
    &#34;&#34;&#34; 
    while f &lt; l:

        mid = (f + l) // 2

        if t[mid] == key:
            return mid
        elif t[mid] &lt; key:
            f = mid + 1
        else:
            l = mid - 1</code></pre>
</details>
</dd>
<dt id="p109.create_min_heap"><code class="name flex">
<span>def <span class="ident">create_min_heap</span></span>(<span>h: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Crea un min heap.</p>
<p>Crea un min heap sobre el array que le es pasado por argumento.</p>
<p>Args: </p>
<pre><code>h (np.ndarray): un array de Numpy.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_min_heap (h:np.ndarray): 
    &#34;&#34;&#34;Crea un min heap.
    
    Crea un min heap sobre el array que le es pasado por argumento.
    
    Args: 

        h (np.ndarray): un array de Numpy.
        
    &#34;&#34;&#34; 
    
    if (len(h)==0): 
        return
    
    i = ((len(h)-1)-1)/2
    
    while i &gt; -1: 
        min_heapify (h, i)
        i = i - 1</code></pre>
</details>
</dd>
<dt id="p109.insert_min_heap"><code class="name flex">
<span>def <span class="ident">insert_min_heap</span></span>(<span>h: numpy.ndarray, k: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Inserta un nuevo nodo.</p>
<p>Inserta un nuevo nodo en un min heap existente.</p>
<p>Args: </p>
<pre><code>h (np.ndarray): el min heap.

k (int): el nuevo nodo/valor a insertar.
</code></pre>
<p>Returns: </p>
<pre><code>h (np.ndarray): el min heap con el nodo insertado.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_min_heap(h: np.ndarray, k: int) -&gt; np.ndarray:
    &#34;&#34;&#34;Inserta un nuevo nodo.
    
    Inserta un nuevo nodo en un min heap existente.
    
    Args: 

        h (np.ndarray): el min heap.
        
        k (int): el nuevo nodo/valor a insertar. 
    
    Returns: 

        h (np.ndarray): el min heap con el nodo insertado.
        
    &#34;&#34;&#34; 

    if h == None: 
        h == []
    
    h += [k]
    j = len(h) - 1
    
    while j&gt;=1 and h[(j-1)//2] &gt; h[j]:
        h[(j-1)//2], h[j] = h[j], h[(j-1)//2]
        j = (j-1)//2
    
    return h</code></pre>
</details>
</dd>
<dt id="p109.matrix_multiplication"><code class="name flex">
<span>def <span class="ident">matrix_multiplication</span></span>(<span>m_1: numpy.ndarray, m_2: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Multiplica 2 matrices.</p>
<p>Devuelve la matriz multiplicada.</p>
<p>Args: </p>
<pre><code>m_1 (np.ndarray): una matriz para multiplicar.

m_2 (np.ndarray): una matriz para multiplicar.
</code></pre>
<p>Returns: </p>
<pre><code>m_3 (np.ndarray): la matriz resultado de la multiplicacion de m_1 * m_2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrix_multiplication (m_1: np.ndarray, m_2: np.ndarray)-&gt; np.ndarray: 
    &#34;&#34;&#34;Multiplica 2 matrices.
    
    Devuelve la matriz multiplicada.
    
    Args: 

        m_1 (np.ndarray): una matriz para multiplicar.
        
        m_2 (np.ndarray): una matriz para multiplicar. 
    
    Returns: 
    
        m_3 (np.ndarray): la matriz resultado de la multiplicacion de m_1 * m_2
        
    &#34;&#34;&#34; 
    return np.multiply(m_1, m_2)</code></pre>
</details>
</dd>
<dt id="p109.min_heapify"><code class="name flex">
<span>def <span class="ident">min_heapify</span></span>(<span>h: numpy.ndarray, i: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Comprueba que los hijos son menores del padre que ocupa la posicion i.</p>
<p>Modifica el heap de tal forma que el elemento de la posicion i, sus hijos sean menores que él.</p>
<p>Args: </p>
<pre><code>h (np.ndarray): un heap.

i (int): la posicion del elemento el cual se quiere hacer heapify.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_heapify(h: np.ndarray, i: int):
    &#34;&#34;&#34;Comprueba que los hijos son menores del padre que ocupa la posicion i.
    
    Modifica el heap de tal forma que el elemento de la posicion i, sus hijos sean menores que él.
    
    Args: 

        h (np.ndarray): un heap.
        
        i (int): la posicion del elemento el cual se quiere hacer heapify. 
        
    &#34;&#34;&#34; 
    
    while 2*i+1 &lt; len(h):
        n_i = i
        if h[int(n_i)] &gt; h[int(2*i+1)]:
            n_i = 2*i+1
        if 2*i+2 &lt; len(h) and h[int(n_i)] &gt; h[int(2*i+2)]:
            n_i = 2*i+2
        if n_i &gt; i:
            h[int(i)], h[int(n_i)] = h[int(n_i)], h[int(i)]
            i = n_i
        else:
            return</code></pre>
</details>
</dd>
<dt id="p109.pq_ini"><code class="name flex">
<span>def <span class="ident">pq_ini</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Inicializa una cola de prioridad. </p>
<p>Returns: </p>
<pre><code>pq (lista): la cola de prioridad vacia.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pq_ini(): 
    &#34;&#34;&#34;Inicializa una cola de prioridad. 
    
    Returns: 

        pq (lista): la cola de prioridad vacia.
        
    &#34;&#34;&#34; 
    pq = []
    return pq </code></pre>
</details>
</dd>
<dt id="p109.pq_insert"><code class="name flex">
<span>def <span class="ident">pq_insert</span></span>(<span>h: numpy.ndarray, k: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Inserta un nuevo valor en la cola de prioridad.</p>
<p>Inserta un nuevo nodo en un min heap existente.</p>
<p>Args: </p>
<pre><code>h (np.ndarray): la cola de prioridad en la que hay que insertar el valor.

k (int): el nuevo nodo/valor a insertar.
</code></pre>
<p>Returns: </p>
<pre><code>h (np.ndarray): la lista con el nuevo nodo insertado.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pq_insert (h: np.ndarray, k:int)-&gt; np.ndarray:  
    &#34;&#34;&#34;Inserta un nuevo valor en la cola de prioridad.
    
    Inserta un nuevo nodo en un min heap existente.
    
    Args: 

        h (np.ndarray): la cola de prioridad en la que hay que insertar el valor.
        
        k (int): el nuevo nodo/valor a insertar. 
    
    Returns: 

        h (np.ndarray): la lista con el nuevo nodo insertado.
        
    &#34;&#34;&#34; 
    
    if len(h)==0: 
        return None
    
    return insert_min_heap (h, k)</code></pre>
</details>
</dd>
<dt id="p109.pq_remove"><code class="name flex">
<span>def <span class="ident">pq_remove</span></span>(<span>h: numpy.ndarray) ‑> tuple[int, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Extrae la raiz.</p>
<p>Elimina la raiz, la reemplaza por el ultimo nodo y comprueba si sigue siendo un min heap.</p>
<p>Args: </p>
<pre><code>h (np.ndarray): la cola de prioridad en la que hay que extraer la raiz.
</code></pre>
<p>Returns: </p>
<pre><code>tuple[int, np.ndarray]: la cola de prioridad sin la raiz original y el valor extraido
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pq_remove(h: np.ndarray)-&gt; tuple[int, np.ndarray]: 
    &#34;&#34;&#34;Extrae la raiz.
    
    Elimina la raiz, la reemplaza por el ultimo nodo y comprueba si sigue siendo un min heap.
    
    Args: 

        h (np.ndarray): la cola de prioridad en la que hay que extraer la raiz.
    
    Returns: 

        tuple[int, np.ndarray]: la cola de prioridad sin la raiz original y el valor extraido
        
    &#34;&#34;&#34; 
    if len(h)==0 : 
        return (h[0], h)
    
    k = h[0]
    h[0] = h[-1]
    min_heapify (h, 0)
    
    return (k, h)</code></pre>
</details>
</dd>
<dt id="p109.rec_bb"><code class="name flex">
<span>def <span class="ident">rec_bb</span></span>(<span>t: list, f: int, l: int, key: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Busca un elemento en un array ordenado.</p>
<p>Divide el array por la mitad, comprueba si el elemento que ocupa la posicion en la mitad es mayor o menor que el elemento que queremos insertar,
y dependiendo de lo que sea, volvemos a dividir y ejecutar el mismo proceso con la mitad superior o inferior de la tabla.</p>
<p>Args: </p>
<pre><code>t (list): la lista en la que queremos buscar el elemento.

f (int): el indice del primer elemento de la tabla.

l (int): el indice del ultimo elemento de la tabla.

key (int): el elemento que queremos buscar
</code></pre>
<p>Returns: </p>
<pre><code>p (int): la posicion del elemento que queremos buscar
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rec_bb(t: list, f: int, l: int, key: int)-&gt; int:  
    &#34;&#34;&#34;Busca un elemento en un array ordenado.
    
    Divide el array por la mitad, comprueba si el elemento que ocupa la posicion en la mitad es mayor o menor que el elemento que queremos insertar, 
    y dependiendo de lo que sea, volvemos a dividir y ejecutar el mismo proceso con la mitad superior o inferior de la tabla.
    
    Args: 

        t (list): la lista en la que queremos buscar el elemento.
        
        f (int): el indice del primer elemento de la tabla. 
        
        l (int): el indice del ultimo elemento de la tabla. 
        
        key (int): el elemento que queremos buscar
    
    Returns: 

        p (int): la posicion del elemento que queremos buscar
        
    &#34;&#34;&#34; 
    
    if f&gt;l : 
        return None
    
    mid = (f+l) // 2
    
    if key==t[mid] : 
        return mid
    elif key&lt;t[mid] : 
        return rec_bb (t, f, mid-1, key)
    else : 
        return rec_bb (t, mid+1, l, key)</code></pre>
</details>
</dd>
<dt id="p109.select_min_heap"><code class="name flex">
<span>def <span class="ident">select_min_heap</span></span>(<span>h: numpy.ndarray, k: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Retorna el valor que ocuparia la posicion k en un array ordenado.</p>
<p>Args: </p>
<pre><code>h (np.ndarray): el min heap.

k (int): la posicion que ocuparia
</code></pre>
<p>Returns: </p>
<pre><code>p (int): el elemento que ocuparia la posicion k en un array ordenado
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_min_heap(h: np.ndarray, k: int)-&gt; int: 
    &#34;&#34;&#34;Retorna el valor que ocuparia la posicion k en un array ordenado.
    
    Args: 

        h (np.ndarray): el min heap.
        
        k (int): la posicion que ocuparia
    
    Returns: 

        p (int): el elemento que ocuparia la posicion k en un array ordenado
        
    &#34;&#34;&#34; 
    h_aux = []
    
    for i in range (0, k) : 
      insert_min_heap (h_aux, -h[i])

    for i in range (0, len(h)) : 
      if -h[i] &gt; h_aux[0] : 
        h_aux = pq_remove (h_aux)[1]
        h_aux = insert_min_heap(h_aux, -h[i])
    
    return -h_aux[0]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="p109.bb" href="#p109.bb">bb</a></code></li>
<li><code><a title="p109.create_min_heap" href="#p109.create_min_heap">create_min_heap</a></code></li>
<li><code><a title="p109.insert_min_heap" href="#p109.insert_min_heap">insert_min_heap</a></code></li>
<li><code><a title="p109.matrix_multiplication" href="#p109.matrix_multiplication">matrix_multiplication</a></code></li>
<li><code><a title="p109.min_heapify" href="#p109.min_heapify">min_heapify</a></code></li>
<li><code><a title="p109.pq_ini" href="#p109.pq_ini">pq_ini</a></code></li>
<li><code><a title="p109.pq_insert" href="#p109.pq_insert">pq_insert</a></code></li>
<li><code><a title="p109.pq_remove" href="#p109.pq_remove">pq_remove</a></code></li>
<li><code><a title="p109.rec_bb" href="#p109.rec_bb">rec_bb</a></code></li>
<li><code><a title="p109.select_min_heap" href="#p109.select_min_heap">select_min_heap</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>